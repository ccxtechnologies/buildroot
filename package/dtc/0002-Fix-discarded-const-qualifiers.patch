From 9a1c801a1a3c102bf95c5339c9e985b26b823a21 Mon Sep 17 00:00:00 2001
From: Stephen Gallagher <sgallagh@redhat.com>
Date: Tue, 6 Jan 2026 14:19:30 -0500
Subject: Fix discarded const qualifiers

It's unsafe to implicitly discard the const qualifier on a pointer. In
overlay_fixup_phandle(), this was probably just an oversight, and making
the "sep" variable a const char * is sufficient to fix it.

In create_node(), however, the "p" variable is directly modifying the
buffer pointed to by "const char* node_name". To fix this, we need to
actually make a duplicate of the buffer and operate on that instead.

This introduces a malloc()/free()  and an unbounded strdup() into the
operation, but fdtput isn't a long-running service and the node_name
argument comes directly from argv, so this shouldn't introduce a
significant performance impact.

Signed-off-by: Stephen Gallagher <sgallagh@redhat.com>
Signed-off-by: David Gibson <david@gibson.dropbear.id.au>
---
 libfdt/fdt_overlay.c | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

(limited to 'libfdt/fdt_overlay.c')

diff --git a/libfdt/fdt_overlay.c b/libfdt/fdt_overlay.c
index e6b9eb6..51a3859 100644
--- a/libfdt/fdt_overlay.c
+++ b/libfdt/fdt_overlay.c
@@ -407,7 +407,8 @@ static int overlay_fixup_phandle(void *fdt, void *fdto, int symbols_off,
 		const char *fixup_str = value;
 		uint32_t path_len, name_len;
 		uint32_t fixup_len;
-		char *sep, *endptr;
+		const char *sep;
+		char *endptr;
 		int poffset, ret;
 
 		fixup_end = memchr(value, '\0', len);
-- 
cgit 1.2.3-korg

From 9a1c801a1a3c102bf95c5339c9e985b26b823a21 Mon Sep 17 00:00:00 2001
From: Stephen Gallagher <sgallagh@redhat.com>
Date: Tue, 6 Jan 2026 14:19:30 -0500
Subject: Fix discarded const qualifiers

It's unsafe to implicitly discard the const qualifier on a pointer. In
overlay_fixup_phandle(), this was probably just an oversight, and making
the "sep" variable a const char * is sufficient to fix it.

In create_node(), however, the "p" variable is directly modifying the
buffer pointed to by "const char* node_name". To fix this, we need to
actually make a duplicate of the buffer and operate on that instead.

This introduces a malloc()/free()  and an unbounded strdup() into the
operation, but fdtput isn't a long-running service and the node_name
argument comes directly from argv, so this shouldn't introduce a
significant performance impact.

Signed-off-by: Stephen Gallagher <sgallagh@redhat.com>
Signed-off-by: David Gibson <david@gibson.dropbear.id.au>
---
 fdtput.c | 8 +++++---
 1 file changed, 5 insertions(+), 3 deletions(-)

(limited to 'fdtput.c')

diff --git a/fdtput.c b/fdtput.c
index 05f2b93..fdb581a 100644
--- a/fdtput.c
+++ b/fdtput.c
@@ -254,19 +254,21 @@ static int create_paths(char **blob, const char *in_path)
 static int create_node(char **blob, const char *node_name)
 {
 	int node = 0;
-	char *p;
+	const char *p;
+	char *path = NULL;
 
 	p = strrchr(node_name, '/');
 	if (!p) {
 		report_error(node_name, -1, -FDT_ERR_BADPATH);
 		return -1;
 	}
-	*p = '\0';
 
 	*blob = realloc_node(*blob, p + 1);
 
 	if (p > node_name) {
-		node = fdt_path_offset(*blob, node_name);
+		path = xstrndup(node_name, (size_t)(p - node_name));
+		node = fdt_path_offset(*blob, path);
+		free(path);
 		if (node < 0) {
 			report_error(node_name, -1, node);
 			return -1;
-- 
cgit 1.2.3-korg